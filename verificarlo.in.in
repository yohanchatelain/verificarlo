#!/usr/bin/env python3
#*******************************************************************************
#                                                                              *
#  This file is part of Verificarlo.                                           *
#                                                                              *
#  Copyright (c) 2015-2020                                                     *
#     Verificarlo contributors                                                 *
#     Universite de Versailles St-Quentin-en-Yvelines                          *
#     CMLA, Ecole Normale Superieure de Cachan                                 *
#                                                                              *
#  Verificarlo is free software: you can redistribute it and/or modify         *
#  it under the terms of the GNU General Public License as published by        *
#  the Free Software Foundation, either version 3 of the License, or           *
#  (at your option) any later version.                                         *
#                                                                              *
#  Verificarlo is distributed in the hope that it will be useful,              *
#  but WITHOUT ANY WARRANTY; without even the implied warranty of              *
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               *
#  GNU General Public License for more details.                                *
#                                                                              *
#  You should have received a copy of the GNU General Public License           *
#  along with Verificarlo.  If not, see <http://www.gnu.org/licenses/>.        *
#                                                                              *
#*******************************************************************************

from __future__ import print_function

import argparse
import os
import sys
import subprocess
import tempfile

PACKAGE_STRING = "@PACKAGE_STRING@"
LIBDIR = "%LIBDIR%"
PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))
libvfcinstrument = LIBDIR + '/libvfcinstrument.so'
mcalib_options = "-rpath {0} -L {0}".format(LIBDIR)
mcalib_includes = PROJECT_ROOT + "/../include/"
vfcwrapper = mcalib_includes + 'vfcwrapper.c'
llvm_bindir = "@LLVM_BINDIR@"
clang = '@CLANG_PATH@'
flang = '@FLANG_PATH@'
opt = llvm_bindir + '/opt'
FORTRAN_EXTENSIONS = [".f", ".f90", ".f77"]
C_EXTENSIONS = [".c", ".cpp", ".cc", ".cxx"]
ASSEMBLY_EXTENSIONS = [".s"]
OBJECT_EXTENSIONS = ['.o']

class NoPrefixParser(argparse.ArgumentParser):
    # ignore prefix autocompletion of options
    def _get_option_tuples(self, option_string):
        return []


def fail(msg):
    print(sys.argv[0] + ': ' + msg, file=sys.stderr)
    sys.exit(1)


def is_fortran(name):
    return os.path.splitext(name)[1].lower() in FORTRAN_EXTENSIONS


def is_c(name):
    return os.path.splitext(name)[1].lower() in C_EXTENSIONS

def is_assembly(name):
    return os.path.splitext(name)[1].lower() in ASSEMBLY_EXTENSIONS

def is_object(name):
    return os.path.splitext(name)[1].lower() in OBJECT_EXTENSIONS

def shell_escape(argument):
    # prevents argument expansion in shell call
    return "'" + argument + "'"

def parse_extra_args(args):
    sources = []
    options = []
    objects = []

    for a in args:
        if is_fortran(a):
            if not flang:
                fail("fortran not supported. "
                     + "--without-flang was used during configuration.")
            sources.append(a)
        elif is_c(a):
            sources.append(a)
        elif is_object(a):
            objects.append(a)
        elif is_assembly(a):
            sources.append(a)
        else:
            options.append(shell_escape(a))

    return sources, objects, ' '.join(options)


def shell(cmd):
    try:
        if args.show_cmd:
            print(cmd)
        subprocess.check_call(cmd, shell=True)
    except subprocess.CalledProcessError:
        fail('command failed:\n' + cmd)

def sources_to_objs(sources):
    objs = []
    for s in sources:
        objs.append(os.path.splitext(s)[0] + '.o')
    return objs

# Find which .o files contains the main function
# Return clang if .c or flang if .f
def choose_linker(sources):
    for source in sources:
        obj = os.path.splitext(source)[0] + ".o"
        code,get_syms = subprocess.getstatusoutput("nm --defined-only " + obj)
        if code != 0:
            print(code,get_syms)
            exit(1)
        syms = get_syms.split("\n")
        for sym in syms:
            (_,_,function) = sym.split()
            if function == "main":
                return clang
            elif function == "MAIN_":
                return flang
            elif function == "__pyx_n_s_main":
                return clang

    if all([is_c(s) for s in sources]):
        return clang
    elif all([is_fortran(s) for s in sources]):
        return flang
    else:
        print("Error: unkwnon language")

def linker_mode(sources, options, output, args):
    extra_args = "-static " if args.static else "-fPIC "
    extra_args += "-DINST_FCMP " if args.inst_fcmp else ""
    extra_args += "-DDDEBUG " if args.ddebug else ""
    shell('{clang} -c -O3 {extra_args} -o .vfcwrapper.o {vfcwrapper} -I {mcalib_includes}'.format(
        clang=clang,
        extra_args=extra_args,
        vfcwrapper=vfcwrapper,
        mcalib_includes=mcalib_includes))

    f = tempfile.NamedTemporaryFile(mode='w+')
    if args.static:
        f.write('{output} {sources} {options} -static .vfcwrapper.o -lmpfr -lgmp -lm -ldl'.format(
            output=output,
            sources=' '.join([os.path.splitext(s)[0]+'.o' for s in sources]),
            options=options))
    else:
        f.write('{output} {sources} {options} .vfcwrapper.o {mcalib_options} -ldl'.format(
            output=output,
            sources=' '.join([os.path.splitext(s)[0]+'.o' for s in sources]),
            options=options,
            mcalib_options=mcalib_options))

    f.flush()
    linker = choose_linker(sources)
    shell('{linker} @{temp}'.format(linker=linker, temp=f.name))
    f.close()

def compiler_only(sources, options, output, args):    
    for source in sources:
        basename = os.path.splitext(source)[0]
        compiler = flang if is_fortran(source) else clang
        if not output:
            output = '-o ' + basename + '.o'
        shell('{compiler} -c {source} {options} {output}'.format(
            compiler=compiler,
            source=source,
            options=options,
            output=output))

def compiler_mode(sources, options, output, args):
    for source in sources:

        if is_assembly(source):
            opts = options
            if not args.c:
                opts += ' -c '
            compiler_only([source], opts, output, args)
            continue

        basename = os.path.splitext(source)[0]
        ir = basename + '.1.ll'
        ins = basename + '.2.ll'

        compiler = flang if is_fortran(source) else clang

        if args.E:
            shell('{compiler} -E {source} {options}'.format(
                compiler=compiler,
                source=source,
                options=options,
                ))
            return

        # Compile to ir (fortran uses flang, c uses clang)
        shell('{compiler} -c -S {source} -emit-llvm {options} -o {ir}'.format(
            compiler=compiler,
            source=source,
            options=options,
            ir=ir))

        selectfunction = ""
        if args.function:
            selectfunction = "-vfclibinst-function " + args.function
        else:
            if args.include_file:
                selectfunction = "-vfclibinst-include-file " + args.include_file
            if args.exclude_file:
                selectfunction += " -vfclibinst-exclude-file " + args.exclude_file

        extra_args = ""

        # Activate verbose mode
        if args.verbose:
            extra_args += "-vfclibinst-verbose "

        # Activate fcmp instrumentation
        if args.inst_fcmp:
            extra_args += "-vfclibinst-inst-fcmp "

        # Apply MCA instrumentation pass
        shell('{opt} -S  -load {libvfcinstrument} -vfclibinst {extra_args} {selectfunction} {ir} -o {ins}'.format(
            opt=opt,
            libvfcinstrument=libvfcinstrument,
            selectfunction=selectfunction,
            extra_args=extra_args,
            ir=ir,
            ins=ins
            ))

        if not output:
            output = '-o ' + basename + '.o'
        # Produce object file
        shell('{compiler} -c {output} {ins} {options}'.format(
            compiler=compiler,
            output=output,
            ins=ins,
            options=options))

if __name__ == "__main__":
    parser = NoPrefixParser(description='Compiles a program replacing floating point operation with calls to the mcalib (Montecarlo Arithmetic).')
    parser.add_argument('-c', action='store_true', help='only run preprocess, compile, and assemble steps')
    parser.add_argument('-o', metavar='file', help='write output to <file>')
    parser.add_argument('--ddebug', action='store_true', help='enable delta-debug mode')
    parser.add_argument('--function', metavar='function', help='only instrument <function>')
    parser.add_argument('--include-file', metavar='file', help='white-list module and functions')
    parser.add_argument('--exclude-file', metavar='file', help='black-list module and functions')
    parser.add_argument('-static', '--static', action='store_true', help='produce a static binary')
    parser.add_argument('--verbose', action='store_true', help='verbose output')
    parser.add_argument('--inst-fcmp', action='store_true', help='instrument floating point comparisons')
    parser.add_argument('--show-cmd', action='store_true', help='show internal commands')
    parser.add_argument('--version', action='version', version=PACKAGE_STRING)
    parser.add_argument('-E', action='store_true', help='stop after preprocessing stage')

    args, other = parser.parse_known_args()

    sources, objects, llvm_options = parse_extra_args(other)
        
    # check input files
    ss = [s for s in sources if is_c(s) or is_fortran(s)]
    if len(ss) > 1 and args.o:
        fail('cannot specify -o when generating multiple output files')

    # check mutually excluding args
    if args.function and (args.include_file or args.exclude_file):
        fail('Cannot use --function and --include-file/--exclude-file together')

    output = "-o " + args.o if args.o else ""
    if args.c:
        if len(sources) == 0:
            fail('no input files')
        compiler_mode(sources, llvm_options, output, args)
    else:
        if len(sources) == 0 and len(objects) == 0:
            fail('no input files')
        compiler_mode(sources, llvm_options, "", args)
        if not args.E:
            linker_mode(sources + objects, llvm_options, output, args)
            
